\newpage
\section {Билет 12. Полнотекстовый поиск. Алгоритмы без индексов. Поиск с реверсивным индексом.}

Текстом назовем произвольный упорядоченный набор слов в некотором алфавите. Фрагмент текста или просто фрагмент — поднабор текста, в который входят подряд идущие слова с сохранением порядка.
\href{https://clck.ru/pwwdR}{Полнотекстовый поиск} - автоматизированный поиск документов, при котором поиск ведётся не по именам документов, а по их содержимому, всему или существенной части.

\subsection{Безиндексный поиск}
В этом пункте мы рассмотрим поиск с помощью регулярных выражений. Подробнее можно прочитать тут:\href{https://habr.com/ru/company/vk/blog/270507/}{regex}. Регулярные выражения - так называют способ описания шаблонов строковых данных. Если некий набор строковых данных аналогичен тому, что описывается регулярным выражением (РВ), то мы говорим о совпадении РВ с этими строковыми данными.

Простейшим случаем регулярного выражения является одиночный буквенный символ. За исключением метасимволов — $*, +, ?, (, ),|,$ — все символы равны сами себе. Для поиска совпадений с метасимволами нужно добавлять обратный слеш: комбинация символов $\backslash +$ аналогична +.

Два регулярных выражения могут преобразовываться или объединяться, создавая новое регулярное выражение: если E1 соответствует S, а E2 соответствует t, тогда E1|E2 соответствует S или T, а E1E2 соответствует ST.

Метасимволы *, + и? являются операторами цикла:
\begin {itemize}
\item E1* говорит о том, что E1 может встречаться 0 и более раз;
\item E1+ говорит о том, что E1 может встречаться 1 и более раз;
\item E1? говорит о том, что E1 может встречаться 0 или 1 раз.
\end {itemize}

Грубо говоря, регулярный язык представляет собой набор строк, которые могут быть найдены в тексте за один проход с использованием фиксированного объёма памяти. Современные реализации регулярных выражений (в Perl и ряде других языков) используют многочисленные новые операторы и управляющие последовательности. Реализация поиска строки использует понятие конечного автомата, они также известны как машины состояний (state machines). 

\subsection {Реверсивный индекс}
Пусть у нас выборка текстов $T_1, T_2, \dots T_{N}$, занумерованные натуральными числами. Есть несколько ключевых слов $k_1, k_2, \dots k_n$ и есть файлы $F_1, \dots F_n$. В файле $F_i$ записаны номера текстов, в которых встречается слово $k_i$. Приведем пример, пусть есть два слова СТОЛ, СТУЛ, и файлы $F_1, F_2$  имеют вид: \\
$$ F_1: 1,3,4,7,9 $$
$$ F_2: 2,3,4,5,6,8 $$

Пусть номера текстов в файлах отсортированы!
Тогда алгоритм поиска прост: мы производим сливание отсортированных массивов (соответственно, если нам нужно найти слова СТОЛ И СТУЛ, то выбираем файлы в которые входят оба эти слова, если  СТОЛ ИЛИ СТУЛ, то просто сливаем два массива). Так как массивы в файлах отсортированы, то задача слияния выполняется быстро.\\
Вопрос: если один файл изменили, что делать ? Например, в 1 тексте слово ТАБУРЕТКА заменили на СТУЛ. Текст 1 попадает в специальный файл где хранятся удаленные тексты, а номер 1 заменяется, например, на 10 (Подбор номера происходит не произвольным образом, а заменяется на максимальный неиспользованный номер). Тогда:
$$ F_1: 3,4,7,9, 10 $$
$$ F_2: 2,3,4,5,6,8,10 $$
$$DEL (\text{удаленные}): 1$$

Если в 4 файле заменили, слово СТУЛ на ТАБУРЕТКА, то (номер 4 заменяем на 11) имеем:
$$ F_1: 3,7,9, 10, 11 $$
$$ F_2: 2,3,5,6,8,10 $$
$$DEL (\text{удаленные}): 1, 4$$

Когда все номера становятся очень большими их все можно уменьшить.